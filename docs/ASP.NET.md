# ASP.NET

Course Link [Udemy- Mosh Hamedani](https://gale.udemy.com/course/the-complete-aspnet-mvc-5-course/learn/lecture/4847008#overview)

## Introductions

- entry point to the application is program.cs , which creates an app object and starts a kestrel web server. In production scenarios, IIS sits in front of multiple applications and forwards request to the kestrel server.

### Dependency Injection

- In the main application of the program `program.cs`, the dependencies required for the application should be registered, `build.Services` or `IServiceCollection` is the central container of all the dependencies in the application.
- Using this approach, the classes do not have to create object instances whenever a specific dependency is required in a class
- Instead the dependencies are passed to the application, through constructor.

----
- Life Cycle of the DI injection
1. Service Registration (add methods to the `IServiceCollection`)
- Different lifetime scopes of object
    1. Singleton - a single instance is created for the entire runtime
    2. scoped - a new instance is created for each request or every time its needed
    3. transient - a new instance is created everytime a service is required ()
2. class Dependency declaration (a class which requires the object declares the interface type as a parameter in its constructor)
3. Object Creation and Injection
- At run time, when the class requests to make an instance of the interface, the runtime looks up the registery and creates an instance based on the interface lifecycle and injects into the constructor

### Middleware

- This portion of the program sits in between the client and the kestrel web server, the order is important in the middleware declaration

- auth > routing > static files > logging

### ServerSideRendering

- In this type of approach, all requests are made from the browser are handled by the server internally, the components required for the browser are generated by the server
- MVC and Razor pages support SSR

### ClientSide

- In this type, all whole bundle is sent to the client at once, and the client handles the internal actions.
- Blazor supports CSR

- two types of appraoches are followed in blazor pages
1. blazor webassembly - in this all the components are compilied into assembly and sent over to browser which renders the page using its runtime environment
2. blazor server - in this approach, a `signalR` middleware is added which creates a web socket connection between the client and server and it keeps track of all changes made by user and renders appropriately

## MVC

- Model : Representation of a data object used in other classes.
- View : Layer responsible for transformation of information or data from model and present it in UI
- Contoller: Layer responsible for handling all the requests. It interacts with the `Model` to fetch data and `View` to make changes to display in the UI.
- Router : The layer which is responsible for routing the requests to the appropriate controller in the backend.

## Return Types

- ActionResult - whenever a action is invoked in a controller, some specific logic is performed and an `ActionResult` object is returned, which indicates what the server should respond to the request
- ViewResult: This is the most common type, used to render a view template (typically a Razor view) for the client.
- ContentResult: This returns plain text content directly to the client.
- EmptyResult: This indicates no specific content needs to be returned, often used for simple actions that might just perform some processing.
- RedirectResult: This redirects the user's request to a different URL.
- JsonResult: This returns data in JSON format, often used for AJAX requests in web applications.
- JavaScriptResult: This returns a JavaScript code snippet that can be executed on the client-side.

### Routing

- two different methods of routing are offered in .net
1. convention-based routing: In this method, inside the router class, a new map route can be created for a specific controller by passing the controller name and contional paratemers to match the route
2. attribute routing: In this case, the routing is handled by the router class itself, `[Route]` attribute should be declared in the controller class

### ORM

- object Relational Mapper : creates objects based on the relational data from database

- workflow

1. a _DBContext is created to work on the database, a _DBSet is created to create a stack of all the operations to be performed
2. through LINQ new queries are added to the _DBSet and executed on DB using the _DBContext
3. use _DBContext.SaveChanges() to process all stacks

- two different types of approached are followed in entity framework
1. Database first: In this approach , the DB models are created first using which the EF , will create the model classes and controllers
2. Code first: in this approach, the models and controllers are created through which the DB schema's are created. Can perform verisioning and migrations in this approach.

- command line tools for migration `use-migration`,`add-migration`,`update database`

### DTO

- useful for delivering only the required data objects from a data model.
- A new data object is create which caters the specific use , this new object will be sent over the network, without disclosing the details of the main model class.
- AutoMapper can be used to create dto objects and tranform them in the controllers

### gRPC

- This is an another kind of API interface format, main functinalities
1. work on performing remote procedure calls, instead of put,get,post,delete actions
2. serilization and deserialization is performed by protocol buffer or protobuffers
3. a contract is signed between the parties prior to connection to determine the formats

## EF Core

- EF was initially introduced to manage the database objects and connections to the database, EF core was later introduced to support the cross platform functionality


## Testing

Automated tests are used to improve relaibility and are included in the build process or CI/CD pipeline

- Unit Testing: A small chunk or a responsibility of a component is tested, this approach is used to find the error easily rather than going into the rabbit hole

- Integration testing: Mainly used to check if two components are properly configured to execute their tasks (connecting to database , a controller calling a service appropriately)

- Functional Test: Mainly used to test end to end functionality of the application, it tests the complete life cycle.

Different steps in the testing

1. Action - Define the workflow of the testing proc.
2. Mock - Create all the objects and variables required for performing the action.
3. Assert - Post performing the action, check if the required response is noted.



